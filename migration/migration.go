package migration

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"text/tabwriter"

	"github.com/op/go-logging"
	"github.com/pkg/errors"
	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

const (
	isRenamedPVC = "relokator.nine.ch/pvc-migration-renamed"
	// oldReplicaCount specifies how many replicas the resource
	// had before we scaled it down. If this is -1, it was unspecified
	oldReplicaCount = "relokator.nine.ch/pvc-migration-old-replicacount"
	// annotation to mark a compute resource to be tied to a specific
	// PVC's migration. used to scale the compute resource up & down
	pvcMigration = "relokator.nine.ch/pvc-migration"
	// annotation to track the job name of the migration. This is because
	// the job name is autogenerated and not deterministic.
	migrationJob = "relokator.nine.ch/pvc-migration-job"
	// tracks which phase we have last completed on this PVC
	completedMigrationPhase = "relokator.nine.ch/pvc-migration-phase"

	// suffix that is added to the renamed PVC
	migrationSuffix = "-migration"

	// The Key that is put in place of "true" on the ArgoCD admin
	// annotation
	migrationInProgress = "migration-in-progress"
)

var (
	globalSourceClass = "nfs"
	globalTargetClass = "filestore"

	log = logging.MustGetLogger("relokator")
)

type Migrator struct {
	ctx context.Context

	client kubernetesClient

	phases []phase

	state clusterState

	autoConfirmPrompts bool
}

type clusterState map[string]namespaceState

type namespaceState map[string]*state

// state is the state of a single PVC migration
type state struct {
	ns         *corev1.Namespace
	sourcePV   *corev1.PersistentVolume
	sourcePVC  *corev1.PersistentVolumeClaim
	renamedPVC *corev1.PersistentVolumeClaim
	targetPVC  *corev1.PersistentVolumeClaim

	completedPhase string
}

func (s *state) pvcName() string {
	switch {
	case s.sourcePVC != nil:
		return s.sourcePVC.Name
	case s.targetPVC != nil:
		return s.targetPVC.Name
	case s.renamedPVC != nil:
		return removeMigrationSuffix(s.renamedPVC.Name)
	}
	return ""
}

// newState creates a new state with the specified PVC in the given namespace. It ensures that the
// PVCs state matches the migration's phase and populates all possible fields in the state.
func newState(ctx context.Context, client kubernetesClient, nsName, pvcName string) (*state, error) {
	ns, err := client.GetNamespace(ctx, nsName)
	if err != nil {
		return nil, errors.Wrapf(err, "could not get namespace %v", nsName)
	}

	s := &state{ns: ns}

	originalNamePVC, err := client.GetPVC(ctx, pvcName, nsName)
	if err != nil && !apierrors.IsNotFound(err) {
		return nil, err
	}
	if apierrors.IsNotFound(err) {
		originalNamePVC = nil
	}

	renamedPVC, err := client.GetPVC(ctx, withMigrationSuffix(pvcName), nsName)
	if err != nil && !apierrors.IsNotFound(err) {
		return nil, err
	}
	if apierrors.IsNotFound(err) {
		renamedPVC = nil
	}

	var pvName string
	switch {
	case originalNamePVC != nil:
		s.completedPhase = originalNamePVC.Annotations[completedMigrationPhase]
		pvName = originalNamePVC.Spec.VolumeName

	case renamedPVC != nil:
		s.completedPhase = renamedPVC.Annotations[completedMigrationPhase]
		pvName = renamedPVC.Spec.VolumeName

	default:
		return nil, errors.Errorf("could not find PVC %v", pvcName)
	}

	pv, err := client.GetPV(ctx, pvName)
	if err != nil || pv == nil {
		return nil, errors.Wrapf(err, "could not get corresponding PV %s", pvName)
	}
	s.sourcePV = pv

	switch s.completedPhase {
	case "", "retainPolicy", "scaleDown":
		if originalNamePVC == nil {
			return nil, errors.Errorf("could not find PVC %v", pvcName)
		}
		if renamedPVC != nil {
			return nil, errors.Errorf("found renamed PVC %v, but does not match phase %q", renamedPVC.Name, s.completedPhase)
		}

		s.sourcePVC = originalNamePVC

	case "recreatePVC", "switchTargetPVC":
		if originalNamePVC != nil {
			// TODO: we could also proactively delete the PVC instead...
			return nil, errors.Errorf("found original PVC %v, but does not match phase %q", originalNamePVC.Name, s.completedPhase)
		}

		if renamedPVC == nil {
			return nil, errors.Errorf("could not find renamed PVC %v", withMigrationSuffix(pvcName))
		}

		s.renamedPVC = renamedPVC

	case "createTargetPVC", "migrateData", "scaleUp":
		if originalNamePVC == nil {
			return nil, errors.Errorf("PVC %v does not exist", pvcName)
		}
		if renamedPVC == nil {
			return nil, errors.Errorf("renamed PVC %v does not exist", withMigrationSuffix(pvcName))
		}

		s.targetPVC = originalNamePVC
		s.renamedPVC = renamedPVC

	case "cleanUp":
		s.targetPVC = originalNamePVC

	default:
		return nil, errors.Errorf("unknown phase: %q", s.completedPhase)
	}

	return s, nil
}

type phase struct {
	exec func(*state, context.Context, kubernetesClient) error
	string
}

func New(ctx context.Context, client kubernetes.Interface, sourceClass, targetClass string, opts ...Option) (*Migrator, error) {
	globalSourceClass = sourceClass
	globalTargetClass = targetClass

	m := &Migrator{
		ctx:                ctx,
		client:             kubernetesClient{client},
		autoConfirmPrompts: false,
		state:              make(clusterState),
		phases: []phase{
			{(*state).retainPolicy, "retainPolicy"},
			{(*state).scaleDown, "scaleDown"},
			{(*state).recreatePVC, "recreatePVC"},
			{(*state).switchTargetPVC, "switchTargetPVC"},
			{(*state).createTargetPVC, "createTargetPVC"},
			{(*state).migrateData, "migrateData"},
			{(*state).scaleUp, "scaleUp"},
			{(*state).cleanUp, "cleanUp"},
		},
	}

	// apply options
	for _, opt := range opts {
		if err := opt(m); err != nil {
			return nil, errors.Wrapf(err, "could not apply option")
		}
	}

	return m, nil
}

// allNamespaces adds all namespaces to the state that should be migrated
func (c clusterState) allNamespaces(ctx context.Context, client kubernetesClient) error {
	n, err := client.ListNamespaces(ctx)
	if err != nil {
		return err
	}
	for _, ns := range n {
		c[ns.Name] = nil
	}
	return nil
}

// allPVCs adds all PVCs to the state that should be migrated
func (c clusterState) allPVCs(ctx context.Context, client kubernetesClient, namespace string) error {
	p, err := client.ListPVCs(ctx, namespace)
	if err != nil {
		return errors.Wrapf(err, "could not list PVs")
	}
	for _, pvc := range p {
		if pvc.Spec.StorageClassName == nil || *pvc.Spec.StorageClassName != globalSourceClass {
			log.Debugf("%v/%v: storageClass of PVC is %q, not %q. not migrating", namespace, pvc.Name, *pvc.Spec.StorageClassName, globalSourceClass)
			continue
		}
		// TODO: figure out if a PVC is in Terminating state and ignore it

		if c[namespace] == nil {
			c[namespace] = make(namespaceState)
		}
		c[namespace][pvc.Name], err = newState(ctx, client, namespace, pvc.Name)
		if err != nil {
			return errors.Wrapf(err, "could not create state")
		}
	}

	return nil
}

func (m *Migrator) String() string {
	debug := false
	if logging.GetLevel("") == logging.DEBUG {
		debug = true
	}

	var str strings.Builder

	w := tabwriter.NewWriter(&str, 6, 8, 2, ' ', 0)
	// header
	if debug {
		fmt.Fprint(w, "namespace\tPVC\tis renamed\tPV\tlast Phase\tnext Phase\n")
		fmt.Fprint(w, "---------\t------\t----------\t------\t----------\t----------\n")
	} else {
		fmt.Fprint(w, "namespace\tPVC\tPV\n")
		fmt.Fprint(w, "---------\t------\t------\n")
	}

	for ns, nsState := range m.state {
		for pvc, pvcState := range nsState {
			var isRenamed bool
			if pvcState.renamedPVC != nil {
				isRenamed = true
			}
			currentPhase, nextPhase := "none", "none"
			if pvcState.completedPhase != "" {
				currentPhase = pvcState.completedPhase
			}

			p := m.getPhases(pvcState.completedPhase)
			if len(p) != 0 {
				nextPhase = p[0].string
			}

			if debug {
				fmt.Fprintf(w, "%s\t%s\t%v\t%s\t%s\t%s\n", ns, pvc,
					isRenamed, pvcState.sourcePV.Name, currentPhase,
					nextPhase,
				)
			} else {
				fmt.Fprintf(w, "%s\t%s\t%s\n", ns, pvc, pvcState.sourcePV.Name)
			}
		}
	}
	if err := w.Flush(); err != nil {
		panic(err)
	}

	return str.String()
}

// toggleArgoAdmin enables or disables the admin access for argo in the specified namespace
func (m *Migrator) toggleArgoAdmin(ns *corev1.Namespace) error {
	const argoAnnotation = "nine.ch/argo-admin"

	val, ok := ns.Annotations[argoAnnotation]
	if !ok {
		return nil
	}

	n, err := m.client.UpdateNamespace(m.ctx, ns, func(ns *corev1.Namespace) {
		switch val {
		case migrationInProgress:
			addAnnotation(ns, argoAnnotation, "true")
		case "true":
			addAnnotation(ns, argoAnnotation, migrationInProgress)
		default:
			// nothing to toggle
		}
	})
	if err != nil {
		return errors.Wrapf(err, "error removing Argo as Admin")
	}

	// update the namespace, but don't change the pointer.
	*ns = *n
	return nil
}

func (m *Migrator) Migrate() error {
	if len(m.state) == 0 {
		log.Debugf("-/-: searching for all namespaces")
		if err := m.state.allNamespaces(m.ctx, m.client); err != nil {
			return errors.Wrapf(err, "could not setup cluster state")
		}
	}

	for namespace, nsState := range m.state {
		// if it's not nil, it has been populated by an option and we don't want to touch it
		if nsState != nil {
			log.Debugf("%v/-: namespace has non-nil state, migrating only predefined targets", namespace)
			continue
		}

		log.Debugf("%v/-: getting all PVCs in namespace to migrate", namespace)
		if err := m.state.allPVCs(m.ctx, m.client, namespace); err != nil {
			return errors.Wrapf(err, "could not create namespace state")
		}
	}

	// if there's no work, exit early
	if m.noWork() {
		log.Infof("no PVC found to migrate")
		return nil
	}

	if err := m.promptUser(); err != nil {
		return err
	}

	var wg sync.WaitGroup
	defer wg.Wait()

	var e Errors
	for ns, nsState := range m.state {
		if err := m.namespace(ns, nsState); err != nil {
			e.Add(err)
		}
	}

	return e.OrNil()
}

// noWork returns true if there is no PVC to migrate
func (m *Migrator) noWork() bool {
	if len(m.state) == 0 {
		return true
	}

	for _, s := range m.state {
		for _, n := range s {
			if n.completedPhase != "cleanUp" {
				return false
			}
		}
	}

	return true
}

func (m *Migrator) promptUser() error {
	log.Infof("Will migrate the following PVCs:\n\n%v\n---------------------", m.String())

	if m.autoConfirmPrompts {
		return nil
	}

	fmt.Println("Confirm (y)es / (n)o:")

	var confirm func() bool
	confirm = func() bool {
		var response string

		_, err := fmt.Scanln(&response)
		if err != nil {
			fmt.Println("please type (y)es or (n)o and then press enter:")
			return confirm()
		}

		switch strings.ToLower(response) {
		case "y", "yes":
			return true
		case "n", "no":
			return false
		default:
			fmt.Println("please type (y)es or (n)o and then press enter:")
			return confirm()
		}
	}
	if !confirm() {
		return errors.New("aborted by user input")
	}
	return nil
}

func (m *Migrator) namespace(ns string, nsState namespaceState) error {
	log.Infof("starting migration in namespace %v", ns)

	// grab the namespace from the first state
	// TODO: should we embed the namespace in the namespaceState?
	var namespace *corev1.Namespace
	for _, st := range nsState {
		namespace = st.ns
		break
	}

	if err := m.toggleArgoAdmin(namespace); err != nil {
		return errors.Wrapf(err, "could not toggle Argo admin")
	}

	defer func() {
		if err := m.toggleArgoAdmin(namespace); err != nil {
			log.Errorf("error toggling Argo Admin: %v", err)
		}
	}()

	var e Errors
	var wg sync.WaitGroup
	for pvc, pvcState := range nsState {
		wg.Add(1)
		go func(pvc string, pvcState *state) {
			defer wg.Done()
			if err := m.runPhases(pvcState); err != nil {
				e.Add(ErrMigration{
					ns:  ns,
					err: err,
					pvc: pvc,
				})
			}
			log.Infof("%v/%v: migration completed", ns, pvc)
		}(pvc, pvcState)
	}

	wg.Wait()

	log.Infof("migration in namespace %v completed", ns)
	return e.OrNil()
}

type Errors struct {
	e []error
	sync.Mutex
}

func (e *Errors) Add(errs ...error) {
	e.Lock()
	defer e.Unlock()
	e.e = append(e.e, errs...)
}

func (e *Errors) OrNil() error {
	e.Lock()
	defer e.Unlock()
	if len(e.e) == 0 {
		return nil
	}
	return e
}

func (e *Errors) Error() string {
	e.Lock()
	defer e.Unlock()
	return fmt.Sprintf("Errors while migrating: %v", e.e)
}

type ErrMigration struct {
	ns  string
	err error
	pvc string
}

func (e ErrMigration) Error() string {
	return fmt.Sprintf("Migration Error for PVC %s in namespace %v: %v", e.pvc, e.ns, e.err)
}

func (m *Migrator) getPhases(val string) []phase {
	for i, phase := range m.phases {
		if phase.string == val {
			return m.phases[i+1:]
		}
	}
	return m.phases
}

func (m *Migrator) runPhases(s *state) error {
	for _, phase := range m.getPhases(s.completedPhase) {
		log.Debugf("%v/%v: starting phase %q", s.ns.Name, s.pvcName(), phase.string)
		if err := phase.exec(s, m.ctx, m.client); err != nil {
			return errors.Wrapf(err, "error in phase %v", phase.string)
		}

		log.Debugf("%v/%v: executed phase %q", s.ns.Name, s.pvcName(), phase.string)
		if err := m.updateTracking(m.ctx, s, phase.string); err != nil {
			return errors.Wrapf(err, "could not update tracking for phase %v", phase.string)
		}
		log.Debugf("%v/%v: tracking updated", s.ns.Name, s.pvcName())
	}
	return nil
}

func (m *Migrator) updateTracking(ctx context.Context, s *state, phase string) error {
	for _, pvc := range []*corev1.PersistentVolumeClaim{s.sourcePVC, s.renamedPVC, s.targetPVC} {
		if pvc == nil {
			continue
		}

		p, err := m.client.UpdatePVC(ctx, pvc, func(pvc *corev1.PersistentVolumeClaim) {
			addAnnotation(pvc, completedMigrationPhase, phase)
		})
		if err != nil {
			return errors.Wrapf(err, "error updating phase on PVC")
		}
		*pvc = *p
	}

	return nil
}

func addAnnotation(obj metav1.Object, key, value string) {
	annot := obj.GetAnnotations()
	if annot == nil {
		annot = make(map[string]string)
	}

	annot[key] = value
	obj.SetAnnotations(annot)
}
